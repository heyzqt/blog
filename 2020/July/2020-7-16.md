# 知识点整理

## Vue 响应式原理

Vue 新建了虚拟的 dom 树，Vue 在初始化实例时，会将 data 对象中的属性转换为响应式的数据（getter/settter），响应式数据也就是说，当数据改变时会触发对 dom 树的更新

直接给根节点 data 添加响应式属性是不允许的，但是给 data 中的属性添加响应式的数据是可以的，此时需要用到 set 函数

```javascript
//两种均可
Vue.set(obj, key, value);
this.$set(obj, key, value);
```

### **注意**

如果在一个页面中，data 包含了某个一直会更新值的属性，此时要注意，这个页面随着每次值的更新，页面都会更新。所以尽量把这个一直都更新的值封装到组件中去，而不是放在最外层的 data 中。

## Vue 的事件修饰符

- stop: 阻止事件继续冒泡

- self: 只响应元素自身触发的事件，不会响应经过冒泡的事件，同时不会阻止事件继续冒泡

- once: 只执行 1 次

- capture：事件在捕获阶段处理

- prevent: 阻止元素默认事件，比如 a 标签点击跳转

- passive：与 prevent 是相反的行为，意思是 passive 会执行默认方法，常用在滚动、滑动事件中，@scoll，@touchmove

  - 为什么会有 passive 呢？

  > 因为浏览器内核每次 scoll 和 touchmove 的时候会检查 dom 有没有 preventDefault，如果没有就执行对应的回调，这样会费效率。而浏览器本身是没法优化这一步骤的，如果设置了 passive，则是通知浏览器，该 dom 元素没有阻止默认方法，可以正常执行默认事件，少了检查的步骤，能大大提升效率

  - passive 和 prevent 冲突，同时出现，prevent 会失效

## Dom 的 addEventListener 和 removeEventListener

- 匿名函数是无法被 remove 的

```javascript
let father = document.getElementById("father");
father.addEventListener("click", () => {
  console.log("father");
});

father.removeEventListener("click", () => {
  console.log("father");
}); //无法移除该listener，因为内存地址已经与上面的不同了
```

- remove 方式 1，函数不带参数的情况

```javascript
let father = document.getElementById("father");
father.addEventListener("click", this.clickEvent);
father.removeEventListener("click", this.clickEvent);
```

- remove 方式 2，函数带参数的情况

<!-- todo -->
